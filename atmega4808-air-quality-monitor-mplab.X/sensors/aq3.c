/******************************************************************************
 *  include files
 *****************************************************************************/
#include "aq3.h"
#include "../mcc_generated_files/drivers/i2c_simple_master.h"
#include "../application/parameters.h"
#include "../mcc_generated_files/include/port.h"
#include "../mcc_generated_files/config/clock_config.h"
#include <util/delay.h>
#include "../mcc_generated_files/include/twi0_master.h"
/******************************************************************************
 *  macro definitions
 *****************************************************************************/
#define Wake_set_level(state)      PORTC_set_pin_level(3, (state)) // CS

/* CCS811 register addresses */
#define CCS811_REG_STATUS          (0x00)
#define CCS811_REG_MEAS_MODE       (0x01)
#define CCS811_REG_ALG_RESULT_DATA (0x02)
#define CCS811_REG_RAW_DATA        (0x03)
#define CCS811_REG_ENV_DATA        (0x05)
#define CCS811_REG_NTC             (0x06)
#define CCS811_REG_THRESHOLDS      (0x10)
#define CCS811_REG_BASELINE        (0x11)

#define CCS811_REG_HW_ID           (0x20)
#define CCS811_REG_HW_VER          (0x21)
#define CCS811_REG_FW_BOOT_VER     (0x23)
#define CCS811_REG_FW_APP_VER      (0x24)

#define CCS811_REG_ERROR_ID        (0xe0)

#define CCS811_REG_APP_ERASE       (0xf1)
#define CCS811_REG_APP_DATA        (0xf2)
#define CCS811_REG_APP_VERIFY      (0xf3)
#define CCS811_REG_APP_START       (0xf4)
#define CCS811_REG_SW_RESET        (0xff)

// status register bits
#define CCS811_STATUS_ERROR        (0x01)  // error, details in CCS811_REG_ERROR
#define CCS811_STATUS_DATA_RDY     (0x08)  // new data sample in ALG_RESULT_DATA
#define CCS811_STATUS_APP_VALID    (0x10)  // valid application firmware loaded
#define CCS811_STATUS_FW_MODE      (0x80)  // firmware is in application mode

#define CCS811_ALG_DATA_ECO2_HB   (0)
#define CCS811_ALG_DATA_ECO2_LB   (1)
#define CCS811_ALG_DATA_TVOC_HB   (2)
#define CCS811_ALG_DATA_TVOC_LB   (3)
#define CCS811_ALG_DATA_STATUS    (4)
#define CCS811_ALG_DATA_ERROR_ID  (5)
#define CCS811_ALG_DATA_RAW_HB    (6)
#define CCS811_ALG_DATA_RAW_LB    (7)



/*******************************************************************************
* @Name
*    uint8_t ccs811_InitSensor(void)
* @Param
*    none
* @Returns
*    initialization status
* @Description
*     sensor initialization   
 *******************************************************************************/

void ccs811_InitSensor(void)
{
    const static uint32_t sw_reset = 0x8a72e511;
    static uint8_t app_start = CCS811_REG_APP_START;
    
    Wake_set_level(false); 
    
    
    //perform software reset
    i2c_write4ByteRegister(CCS811_I2C_ADDRESS_1, CCS811_REG_SW_RESET, sw_reset);

    // wait 100 ms after the reset
    _delay_ms(100);

    // swtich to application mode
    i2c_writeNBytes(CCS811_I2C_ADDRESS_1, &app_start, 1);
    
    // wait 100 ms after starting the app
    _delay_ms(100);
        
    
    // try to set default measurement mode to *ccs811_mode_1s*  
	i2c_write1ByteRegister(CCS811_I2C_ADDRESS_1, CCS811_REG_MEAS_MODE, ccs811_mode_1s);
	
	_delay_ms(100);
    
    Wake_set_level(true); 

}


/*******************************************************************************
* @Name
*    uint8_t ccs811_GetResults (uint16_t* iaq_eco2,uint16_t* iaq_tvoc)
* @Param
*    address of variables at which data has to be stored  
* @Returns
*    read status
* @Description
*    read data from sensor    
 *******************************************************************************/
void ccs811_GetResults (uint16_t* iaq_eco2,uint16_t* iaq_tvoc)
{
    Wake_set_level(false); 
    
    uint8_t data[8];

    // read IAQ sensor values and RAW sensor data including status and error id
    i2c_readDataBlock(CCS811_I2C_ADDRESS_1, CCS811_REG_ALG_RESULT_DATA, data, 8);

//    AqmPrinter(DEBUG_AQM, "%d %d %d %d %d %d %d %d ",data[0],data[1],data[2],data[3],data[4],data[5],data[6],data[7]);

    // if *iaq* is not NULL return IAQ sensor values
     *iaq_tvoc = data[CCS811_ALG_DATA_TVOC_HB] << 8 | data[CCS811_ALG_DATA_TVOC_LB];
     *iaq_eco2 = data[CCS811_ALG_DATA_ECO2_HB] << 8 | data[CCS811_ALG_DATA_ECO2_LB];
     
      Wake_set_level(true); 
    
}

/*******************************************************************************
   Below two function are part of i2c drivers. Reason to define the functions 
   here is, these functions are not generated by Atmel START, but required for 
   Air Quality 3 driver. 
 *******************************************************************************/

static twi0_operations_t wr4RegCompleteHandler(void *p)
{
    I2C0_SetBuffer(p,4);
    I2C0_SetDataCompleteCallback(NULL,NULL);
    return I2C0_CONTINUE;
}

void i2c_write4ByteRegister(twi0_address_t address, uint8_t reg, uint32_t data)
{
    while(!I2C0_Open(address)); // sit here until we get the bus..
    I2C0_SetDataCompleteCallback(wr4RegCompleteHandler,&data);
    I2C0_SetBuffer(&reg,1);
    I2C0_SetAddressNackCallback(I2C0_SetRestartWriteCallback,NULL); //NACK polling?
    I2C0_MasterWrite();
    while(I2C0_BUSY == I2C0_Close()); // sit here until finished.
}

/****************************************************************/



